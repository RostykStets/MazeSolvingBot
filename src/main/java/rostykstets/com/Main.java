package rostykstets.com;

import java.util.*;


public class Main {
    private static final int MAZE_SIZE = 10;
    private static char[][] maze;

    // Coordinates
    public static int entranceCoordinateRow;
    public static int entranceCoordinateCol;
    public static int exitCoordinateRow;
    public static int exitCoordinateCol;

    public static Cell botCell;

    public static Stack<Directions> possibleMoves;
    public static Stack<Cell> visitedCells;

    public static void main(String[] args) {

        possibleMoves = new Stack<>();
        visitedCells = new Stack<>();

        generateMaze(MAZE_SIZE);

        botCell = new Cell(entranceCoordinateRow, entranceCoordinateCol);

        solveMaze();
    }

    // Depth-First Search algorithm to generate maze
    // Generated by ChatGPT
    public static void generateMaze(int n) {

        maze = new char[MAZE_SIZE][MAZE_SIZE];
        int[][] DIRECTIONS = {
                {-2, 0}, {2, 0}, {0, -2}, {0, 2}
        };

        // усе стіни
        for (int i = 0; i < n; i++) {
            Arrays.fill(maze[i], Constants.WALL_SYMBOL.symbol);
        }

        Random rand = new Random();

        // стартуємо з випадкової внутрішньої клітинки
        int startRow = rand.nextInt(n / 2) * 2 + 1;
        int startCol = rand.nextInt(n / 2) * 2 + 1;
        maze[startRow][startCol] = Constants.FREE_CELL_SYMBOL.symbol;

        Stack<int[]> stack = new Stack<>();
        stack.push(new int[]{startRow, startCol});

        while (!stack.isEmpty()) {
            int[] cell = stack.peek();
            int row = cell[0], col = cell[1];

            List<int[]> neighbors = new ArrayList<>();

            for (int[] d : DIRECTIONS) {
                int neighborRow = row + d[0];
                int neighborCol = col + d[1];
                if (neighborRow >= 0 && neighborRow < n &&
                        neighborCol >= 0 && neighborCol < n &&
                        maze[neighborRow][neighborCol] == Constants.WALL_SYMBOL.symbol) {
                    neighbors.add(new int[]{neighborRow, neighborCol});
                }
            }

            if (!neighbors.isEmpty()) {
                int[] next = neighbors.get(rand.nextInt(neighbors.size()));
                int neighborRow = next[0], neighborCol = next[1];

                // пробиваємо стіну між
                maze[(row + neighborRow) / 2][(col + neighborCol) / 2] = Constants.FREE_CELL_SYMBOL.symbol;
                maze[neighborRow][neighborCol] = Constants.FREE_CELL_SYMBOL.symbol;

                stack.push(next);
            } else {
                stack.pop();
            }
        }

        // Ставимо вхід (#) на випадковому краю
        int entranceSide = rand.nextInt(4);
        switch (entranceSide) {
            case 0:
                entranceCoordinateRow = 0;
                entranceCoordinateCol = rand.nextInt(n);
                break; // верх
            case 1:
                entranceCoordinateRow = n - 1;
                entranceCoordinateCol = rand.nextInt(n);
                break; // вниз
            case 2:
                entranceCoordinateRow = rand.nextInt(n);
                entranceCoordinateCol = 0;
                break; // вліво
            case 3:
                entranceCoordinateRow = rand.nextInt(n);
                entranceCoordinateCol = n - 1;
                break; // право
        }
        maze[entranceCoordinateRow][entranceCoordinateCol] = Constants.ENTRANCE_SYMBOL.symbol;

        // Ставимо вихід (2) на іншому краю
        int exitSide;
        do {
            exitSide = rand.nextInt(4);
        } while (exitSide == entranceSide);
        switch (exitSide) {
            case 0:
                exitCoordinateRow = 0;
                exitCoordinateCol = rand.nextInt(n);
                break;
            case 1:
                entranceCoordinateRow = n - 1;
                exitCoordinateCol = rand.nextInt(n);
                break;
            case 2:
                exitCoordinateRow = rand.nextInt(n);
                exitCoordinateCol = 0;
                break;
            case 3:
                entranceCoordinateRow = rand.nextInt(n);
                exitCoordinateCol = n - 1;
                break;
        }
        maze[exitCoordinateRow][exitCoordinateCol] = Constants.EXIT_SYMBOL.symbol;
    }

    public static void printMaze() {
        for (char[] chars : maze) {
            for (char c : chars) {
                System.out.print(c + " ");
            }
            System.out.println();
        }
    }

    public static Boolean canMoveUp() {
        // Check if coordinate is out of the bound
        if (botCell.getRow() == 0) {
            return false;
        }

        // Check if there is a wall or visited cell on the top side
        return maze[botCell.getRow() - 1][botCell.getCol()] != Constants.WALL_SYMBOL.symbol &&
                maze[botCell.getRow() - 1][botCell.getCol()] != Constants.VISITED_CELL_SYMBOL.symbol;
    }

    public static Boolean canMoveDown() {
        // Check if coordinate is out of the bound
        if (botCell.getRow() == MAZE_SIZE - 1) {
            return false;
        }

        // Check if there is a wall or visited cell on the bottom side
        return maze[botCell.getRow() + 1][botCell.getCol()] != Constants.WALL_SYMBOL.symbol &&
                maze[botCell.getRow() + 1][botCell.getCol()] != Constants.VISITED_CELL_SYMBOL.symbol;
    }

    public static Boolean canMoveRight() {
        // Check if coordinate is out of the bound
        if (botCell.getCol() == MAZE_SIZE - 1) {
            return false;
        }

        // Check if there is a wall or visited cell on the right side
        return maze[botCell.getRow()][botCell.getCol() + 1] != Constants.WALL_SYMBOL.symbol &&
                maze[botCell.getRow()][botCell.getCol() + 1] != Constants.VISITED_CELL_SYMBOL.symbol;
    }

    public static Boolean canMoveLeft() {
        // Check if coordinate is out of the bound
        if (botCell.getCol() == 0) {
            return false;
        }

        // Check if there is a wall or visited cell on the left side
        return maze[botCell.getRow()][botCell.getCol() - 1] != Constants.WALL_SYMBOL.symbol &&
                maze[botCell.getRow()][botCell.getCol() - 1] != Constants.VISITED_CELL_SYMBOL.symbol;
    }

    public static Directions randomDirection(List<Directions> directions) {
        Random rand = new Random();
        int randomDirectionIndex = rand.nextInt(directions.size());
        return directions.get(randomDirectionIndex);
    }

    public static void solveMaze() {

        int movesCount = 0;

        boolean isSolved = true;

        do {
            possibleMoves.clear();

            // Mark entrance cell on the map
            maze[entranceCoordinateRow][entranceCoordinateCol] = Constants.ENTRANCE_SYMBOL.symbol;

            System.out.printf("\tMove %s\n", movesCount);
            printMaze();
            System.out.println();

            // Limit for moves
            if (movesCount == MAZE_SIZE * MAZE_SIZE) {
                isSolved = false;
                break;
            }

            // Check up possible directions of move
            if (canMoveRight()) {
                possibleMoves.push(Directions.RIGHT);
            }
            if (canMoveLeft()) {
                possibleMoves.push(Directions.LEFT);
            }
            if (canMoveUp()) {
                possibleMoves.push(Directions.UP);
            }

            if (canMoveDown()) {
                possibleMoves.push(Directions.DOWN);
            }

            if (!possibleMoves.isEmpty()) {
                // Move from the current cell and mark it as visited on a map
                maze[botCell.getRow()][botCell.getCol()] = Constants.VISITED_CELL_SYMBOL.symbol;

//                var lastPossibleMove = possibleMoves.pop();
//                botCell.setRow(lastPossibleMove[0]);
//                botCell.setCol(lastPossibleMove[1]);

                // Choose a direction of the possible directions randomly 
                Directions randomDir = randomDirection(possibleMoves.stream().toList());

                switch (randomDir) {
                    case RIGHT:
                        botCell.setCol(botCell.getCol() + 1);
                        break;
                    case LEFT:
                        botCell.setCol(botCell.getCol() - 1);
                        break;
                    case UP:
                        botCell.setRow(botCell.getRow() - 1);
                        break;
                    case DOWN:
                        botCell.setRow(botCell.getRow() + 1);
                        break;
                    default:
                        break;
                }

                // Mark current cell as visited by pushing into stack
                visitedCells.push(new Cell(botCell.getRow(), botCell.getCol()));

                if (maze[botCell.getRow()][botCell.getCol()] != Constants.EXIT_SYMBOL.symbol) {
                    maze[botCell.getRow()][botCell.getCol()] = Constants.BOT_SYMBOL.symbol;
                }
            }
            // If there is no possible direction, move back to the last visited cell  
            else if (!visitedCells.isEmpty()) {
                // Move from the current cell and mark it as visited on a map
                maze[botCell.getRow()][botCell.getCol()] = Constants.VISITED_CELL_SYMBOL.symbol;

                Cell lastVisitedCell = visitedCells.pop();
                botCell = lastVisitedCell;
//                botCell.setRow(lastVisitedCell.getRow());
//                botCell.setCol(lastVisitedCell.getCol());

                maze[botCell.getRow()][botCell.getCol()] = Constants.BOT_SYMBOL.symbol;
            }

            movesCount++;
        }
        // Loop goes on until bot gets to exit cell
        while (maze[botCell.getRow()][botCell.getCol()] != Constants.EXIT_SYMBOL.symbol);

        if (isSolved) {
            System.out.printf("\nBot solved the maze in %s moves!\n", movesCount);
        } else {
            System.out.println("\nBot ran out of moves!");
        }
    }
}